# **********************************************************
# Copyright (c) 2011 Google, Inc.  All rights reserved.
# Copyright (c) 2009-2010 VMware, Inc.  All rights reserved.
# **********************************************************
#
# Dr. Memory: the memory debugger
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; 
# version 2.1 of the License, and no later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
###########################################################################
# Dr. Memory default suppression file

##################################################
# i#65: uninitialized value deliberately used to generate a random number

UNINITIALIZED READ
system call NtDeviceIoControlFile InputBuffer
ADVAPI32.dll!*
...
ADVAPI32.dll!SystemFunction036

##################################################
# i#257: real leak in VS2008 STL std::numpunct<{char,wchar_t}>::_Init

LEAK
...
*!operator new
*!std::_Maklocstr<char>
*!std::numpunct<*>::_Init

LEAK
...
*!operator new
*!operator new[]
*!std::_Maklocstr<char>
*!std::numpunct<*>::_Init

##################################################
# Activation context leaked for certain threads
#
# i#286: when I use _beginthreadex() I see this leak even when explicitly calling
# _endthread().  Not sure whether csrss frees it when it frees the stack
# but suppressing under the assumption it's a false positive.
# I don't see this when using CreateThread.
#
# i#506: InitCommonControlsEx leaks some activation contexts too, with a bunch of
# different frames at the top of the stack

LEAK
ntdll.dll!Rtl*ActivationContext*

# i#286: the first two frames for _beginthreadex are:
#   ntdll.dll!RtlAllocateActivationContextStack
#   KERNEL*.dll!CreateRemoteThread*

# i#445: for remote threads (e.g., nudges) the stacks start with:
#   ntdll.dll!RtlAllocateActivationContextStack
#   ntdll.dll!LdrpInitializeThread
#   ntdll.dll!_LdrpInitialize
#   ntdll.dll!LdrInitializeThunk

# i#506: for InitCommonControlsEx the stacks start with:
#   ntdll.dll!RtlActivateActivationContextEx/RtlpAllocateActivationContextStackFrame
#   ntdll.dll!RtlActivateActivationContextEx
#   ntdll.dll!RtlActivateActivationContext

##################################################
# i#306: these are stored on ntdll!RtlCriticalSectionList
# using an 8-byte-in pointer

POSSIBLE LEAK
...
ntdll.dll!RtlInitializeCriticalSection

##################################################
# i#337: real bug in RtlpLowFragHeapAllocFromContext.
# w/o symbols RtlpLowFragHeapAllocFromContext shows up
# as LdrUnlockLoaderLock so we match all.

UNINITIALIZED READ
ntdll.dll!*
ntdll.dll!RtlAllocateHeap

##################################################
# i#455: real bug in kernel32!BaseDllReadWriteIniFileViaMapping

UNADDRESSABLE ACCESS
system call NtQueryValueKey UNICODE_STRING capacity
kernel32.dll!BaseDllReadWriteIniFileViaMapping

# w/o symbols shows up as various nearby exports.
# so far we've only seen it called from GetPrivateProfileStringA so we match that.
UNADDRESSABLE ACCESS
system call NtQueryValueKey UNICODE_STRING capacity
kernel32.dll!*
kernel32.dll!*
kernel32.dll!GetPrivateProfileStringA

##################################################
# i#462, i#504: Deliberate write to beyond TOS

# with symbols
UNADDRESSABLE ACCESS
CRYPTBASE.dll!AesEncrypt

UNADDRESSABLE ACCESS
RSAENH.dll!AesEncrypt

# w/o symbols
UNADDRESSABLE ACCESS
CRYPTBASE.dll!SystemFunction036

UNADDRESSABLE ACCESS
<RSAENH.dll+0x1b46>

##################################################
# i#492: false positive that needs per-bit granularity (i#113)
# There is a chance of false negative on user-passed input to this
# routine, but it's hard to make this suppression any more specific
# w/o doing mod+offs. The risk is considered short-term until have
# per-bit granularity.

UNINITIALIZED READ
usp10.dll!DoubleWideCharMappedString::DoubleWideCharMappedString

# w/o symbols
UNINITIALIZED READ
usp10.dll!UspFreeMem

##################################################
# i#493: Not fully analyzed but look similar to i#492.
# Likely will go away w/ per-bit granularity (i#113).
# Again, single routine since doesn't depend on caller,
# and some risk of false negative, but considered short-term
# until have per-bit granularity.

UNINITIALIZED READ
usp10.dll!CStackAllocator::Free
# w/o symbols
UNINITIALIZED READ
usp10.dll!UspFreeMem

# the next 4 all have the same no-syms stack:
# w/o symbols
UNINITIALIZED READ
usp10.dll!ScriptPositionSingleGlyph

UNINITIALIZED READ
usp10.dll!GenericEngineGetBreakingProperties

UNINITIALIZED READ
usp10.dll!GenericEngineGetGlyphs

UNINITIALIZED READ
usp10.dll!ShapingGetGlyphPositions

UNINITIALIZED READ
usp10.dll!CUspShapingDrawingSurface::GenericGlyphOut

##################################################
# i#494: Custom data not all initialized

UNINITIALIZED READ
system call NtConnectPort parameter #6
UxTheme.dll!*
UxTheme.dll!*
UxTheme.dll!*
USER32.dll!*

##################################################
# i#497: Likely will go away w/ per-bit granularity (i#113).
# Again, single routine since doesn't depend on caller,
# and some risk of false negative, but considered short-term
# until have per-bit granularity.

UNINITIALIZED READ
gdiplus.dll!DpRegion::FreeData

# w/o symbols
UNINITIALIZED READ
gdiplus.dll!GdipCreateSolidFill

##################################################
# i#529: multi-instr partial xor-with-self
# XXX: A better suppression can be made w/ per-instr
# info via i#498.

UNINITIALIZED READ
RPCRT4.dll!Ndr*
RPCRT4.dll!Ndr*
RPCRT4.dll!*
