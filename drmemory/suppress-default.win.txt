# **********************************************************
# Copyright (c) 2011 Google, Inc.  All rights reserved.
# Copyright (c) 2009-2010 VMware, Inc.  All rights reserved.
# **********************************************************
#
# Dr. Memory: the memory debugger
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; 
# version 2.1 of the License, and no later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
###########################################################################
# Dr. Memory default suppression file

##################################################
# i#65: uninitialized value deliberately used to generate a random number

UNINITIALIZED READ
name=default i#65 (generate random number)
system call NtDeviceIoControlFile InputBuffer
ADVAPI32.dll!*
...
ADVAPI32.dll!SystemFunction036

##################################################
# i#257: real leak in VS2008 STL std::numpunct<{char,wchar_t}>::_Init

LEAK
name=default i#257 (real leak in VS2008 STL std::numpunct<{char,wchar_t}>::_Init)
# this frame can be inlined: *!std::_Maklocstr<char>
...
*!std::numpunct<*>::_Init

##################################################
# Activation context leaked for certain threads
#
# i#286: when I use _beginthreadex() I see this leak even when explicitly calling
# _endthread().  Not sure whether csrss frees it when it frees the stack
# but suppressing under the assumption it's a false positive.
# I don't see this when using CreateThread.
#
# i#506: InitCommonControlsEx leaks some activation contexts too, with a bunch of
# different frames at the top of the stack

LEAK
name=default i#286 (activation context leak)
ntdll.dll!Rtl*ActivationContext*

LEAK
name=default i#286 (activation context leak)
ntdll.dll!*
ntdll.dll!RtlAllocateActivationContextStack

# i#286: the first two frames for _beginthreadex are:
#   ntdll.dll!RtlAllocateActivationContextStack
#   KERNEL*.dll!CreateRemoteThread*

# i#369
#   ntdll.dll!<VARIOUS>
#   ntdll.dll!RtlAllocateActivationContextStack

# i#445: for remote threads (e.g., nudges) the stacks start with:
#   ntdll.dll!RtlAllocateActivationContextStack
#   ntdll.dll!LdrpInitializeThread
#   ntdll.dll!_LdrpInitialize
#   ntdll.dll!LdrInitializeThunk

# i#506: for InitCommonControlsEx the stacks start with:
#   ntdll.dll!RtlActivateActivationContextEx/RtlpAllocateActivationContextStackFrame
#   ntdll.dll!RtlActivateActivationContextEx
#   ntdll.dll!RtlActivateActivationContext

##################################################
# i#306: these are stored on ntdll!RtlCriticalSectionList
# using an 8-byte-in pointer

POSSIBLE LEAK
name=default i#306 (critical section 8-byte-in pointer)
...
ntdll.dll!RtlInitializeCriticalSection

##################################################
# i#337: real bug in RtlpLowFragHeapAllocFromContext.
# w/o symbols RtlpLowFragHeapAllocFromContext shows up
# as LdrUnlockLoaderLock so we match all.

UNINITIALIZED READ
name=default i#337 (real bug in RtlpLowFragHeapAllocFromContext)
ntdll.dll!*
ntdll.dll!RtlAllocateHeap

##################################################
# i#455: real bug in kernel32!BaseDllReadWriteIniFileViaMapping

UNADDRESSABLE ACCESS
name=default i#455 (real bug in kernel32!BaseDllReadWriteIniFileViaMapping)
system call NtQueryValueKey UNICODE_STRING capacity
kernel32.dll!BaseDllReadWriteIniFileViaMapping

# w/o symbols shows up as various nearby exports.
# so far we've only seen it called from GetPrivateProfileStringA so we match that.
UNADDRESSABLE ACCESS
name=default i#455 (real bug in kernel32!BaseDllReadWriteIniFileViaMapping)
system call NtQueryValueKey UNICODE_STRING capacity
kernel32.dll!*
kernel32.dll!*
kernel32.dll!GetPrivateProfileStringA

##################################################
# i#462, i#504: Deliberate write to beyond TOS

# with symbols
UNADDRESSABLE ACCESS
name=default i#462 (write beyond TOS)
instruction=mov    %e?? -> 0xfffffffc(%esp)
CRYPTBASE.dll!AesEncrypt

UNADDRESSABLE ACCESS
name=default i#504 (write beyond TOS)
instruction=mov    %e?? -> 0xfffffffc(%esp)
RSAENH.dll!AesEncrypt

# w/o symbols
UNADDRESSABLE ACCESS
name=default i#462 (write beyond TOS)
instruction=mov    %e?? -> 0xfffffffc(%esp)
CRYPTBASE.dll!SystemFunction036

UNADDRESSABLE ACCESS
name=default i#504 (write beyond TOS)
instruction=mov    %e?? -> 0xfffffffc(%esp)
RSAENH.dll!*

UNADDRESSABLE ACCESS
name=default i#462 (write beyond TOS)
instruction=mov    %e?? -> 0xfffffffc(%esp)
ADVAPI32.dll!*

##################################################
# i#492: false positive that needs per-bit granularity (i#113)
# There is a chance of false negative on user-passed input to this
# routine, but it's hard to make this suppression any more specific
# w/o doing mod+offs. The risk is considered short-term until have
# per-bit granularity.

UNINITIALIZED READ
name=default i#492 (bit manip)
instruction=test   * $0x??
usp10.dll!DoubleWideCharMappedString::DoubleWideCharMappedString

# w/o symbols
UNINITIALIZED READ
name=default i#492 (bit manip)
instruction=test   * $0x??
usp10.dll!UspFreeMem

##################################################
# i#493: Not fully analyzed but look similar to i#492.
# Likely will go away w/ per-bit granularity (i#113).
# Again, single routine since doesn't depend on caller,
# and some risk of false negative, but considered short-term
# until have per-bit granularity.

UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!CStackAllocator::Free
# w/o symbols
UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!UspFreeMem

# the next 4 all have the same no-syms stack:
# w/o symbols
UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!ScriptPositionSingleGlyph

UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!GenericEngineGetBreakingProperties

UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!GenericEngineGetGlyphs

UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!ShapingGetGlyphPositions

UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
usp10.dll!CUspShapingDrawingSurface::GenericGlyphOut

# callstacks on vista
UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=test   * $0x??
USP10.dll!*
USP10.dll!Script*

# cmp instead of test, seen recently on win7 calc
UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=cmp    0x1c(%ebp)*
usp10.dll!CUspShapingDrawingSurface::GenericGlyphOut
# w/o syms
UNINITIALIZED READ
name=default i#493 (bit manip)
instruction=cmp    0x1c(%ebp)*
usp10.dll!ScriptPositionSingleGlyph

##################################################
# i#494: Custom data not all initialized

UNINITIALIZED READ
name=default i#494 (custom data not all initialized)
system call NtConnectPort parameter #6
UxTheme.dll!*
UxTheme.dll!*
UxTheme.dll!*
USER32.dll!*

##################################################
# i#497: Likely will go away w/ per-bit granularity (i#113).
# Again, single routine since doesn't depend on caller,
# and some risk of false negative, but considered short-term
# until have per-bit granularity.

UNINITIALIZED READ
name=default i#497 (gdiplus bit manip)
instruction=test   0x??(%e??) $0x??
gdiplus.dll!DpRegion::FreeData

# w/o symbols
UNINITIALIZED READ
name=default i#497 (gdiplus bit manip)
instruction=test   0x??(%e??) $0x??
gdiplus.dll!GdipCreateSolidFill

##################################################
# i#511: bit manip uninit
# Either will be handled by per-bit granularity,
# is too complex (like i#529), or perhaps is a real
# uninit but deliberate for random number gen:
# regardless we want to suppress.

UNINITIALIZED READ
name=default i#511 (rc4_key bit manip)
instruction=mov    (%ebx,%esi,1) -> %al 
RPCRT4.dll!rc4_key

# w/o symbols.
# this func takes a single OUT pointer so low likelihood
# of false neg since undef pointer will likely be unaddr
# though could be a nearby internal func that maps to this
# w/o syms: we'll live w/ the false negative risk.
UNINITIALIZED READ
name=default i#511 (rc4_key bit manip)
instruction=mov    (%ebx,%esi,1) -> %al 
RPCRT4.dll!UuidCreate

##################################################
# i#529: multi-instr partial xor-with-self
# No good symbols so we match these instructions:
#  test   0x70(%esi) $0x00000400 
#  test   0x70(%esi) $0x00000200 
#  test   0x70(%ebx) $0x00000100 
#  test   0x70(%edi) %esi

UNINITIALIZED READ
name=default i#529 (multi-instr partial xor-with-self)
instruction=test   0x70(%e??) *
RPCRT4.dll!Ndr*
RPCRT4.dll!*

##################################################
# i#655: deliberate mismatch

INVALID HEAP ARGUMENT
name=default i#655: allocate with new and free with free()
*!std::_DebugHeapDelete<*>
